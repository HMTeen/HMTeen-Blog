---
title: 1.基础
createTime: 2025/04/08 11:27:46
permalink: /ToBeABD/SyStemDesign/SyStemDesign/71ik0zy4/
---
# 模块 | 基本概念

## 测试和软件设计三概念：Fake、Stubs、Mocks

参考文章：[https://zhuanlan.zhihu.com/p/26942686](https://zhuanlan.zhihu.com/p/26942686)

# 模块 | 认证授权

## 登录相关概念

### Cookie、Session

参考文章：[文章1](https://blog.csdn.net/huangpb123/article/details/103933400)、[文章2](https://blog.csdn.net/qq_44709990/article/details/123082560)

==【八股】Cookie、Session的概念？==

理解会话的概念：

- HTTP请求是无状态的，服务器不知道该HTTP请求来自哪个客户端
- 若有一种技术能够让服务器知道请求来自哪，这种技术就叫做**会话技术**
- 会话技术有两种实现方式：`Cookie`和 `Session`

会话技术的讲解：

- 概念：客户端和服务端之间放生的一系列连续请求和响应的过程（多次）
- 会话状态：会话过程中产生的状态信息，借助状态信息可以把属于同一个会话的请求和响应关联起来

Cookie和Session的使用：

- 示例：
  - 用户端首次访问服务器，服务器给该用户生成一个唯一的ID信息，存放在服务器中，后续用户访问中产生的信息也会根据该ID存储在服务器；
  - 服务器将该ID返回给客户端，后续客户端每次访问服务器的时候都带着该ID，就能标识该请求来自哪个客户端
- 从示例中引入Cookie和Session的概念：
  - Session：服务器把客户端信息以某种方式记录在服务器上，就是Session
  - Cookie：客户端将返回回来的ID信息存储在浏览器中，这个就是Cookie

Cookie和Session的总结：

|          | Cookie                                     | Session                                            |
| -------- | ------------------------------------------ | -------------------------------------------------- |
| 存储格式 | 文本形式（一般是字符串，比如上述示例的ID） | 可以是多种形式（数字、字符串、二进制）             |
| 存储位置 | 客户端                                     | 服务器                                             |
| 安全性   | 较低一点，不要存储敏感信息                 | 较高一点，保存在服务器                             |
| 数据大小 | 较小，单个Cookie不超过4k                   | 较大，但是数据一旦多起来，对服务端是一个不小的压力 |

基于Cookie+Session可以实现用户的登录认证：

- 具体流程：

  - 客户端用户首次携带账号密码登录
  - 服务器验证用户身份成功后，返回一个唯一的用户ID给客户端
  - 客户端后续携带该ID，就可以在不输入账号和密码的情况下，访问服务器
- 缺点：

  - Cookie可被用于CSRF攻击，安全性较低
  - 若有多个服务器，用户在服务器A上访问后，信息存入Session；用户再次访问服务器B后，信息需要再保存一份到Session；还有Session数据同步问题
- 后续概念引入，解决上述问题：

  - LocalStorage：解决Cookie不安全的问题
  - Token：解决Session+Cookie方法的用户登录认证不足（信息存储量大时的服务器压力；整体认证安全性问题）

### Token、Jwt

==【八股】Token的概念==

Token的概念：Token是访问API所需要的资源凭证

Token的简单组成：用户ID信息、时间戳信息、签名信息

Token的使用理念：

- 客户端将用户的账号密码信息发送给服务器
- 服务器通过一些加密算法，将包含有用户ID、时间戳等的信息加密为一行字符串，返回给客户端
- 客户端将结果存储起来，后续访问的时候携带该字符串，服务器通过验证该字符串的合理性，并反向解析出对应的用户ID等信息，完成身份校验
- 通过这样的流程，服务器将不用额外通过Session存储用户信息，也能实现用户认证

---

==【八股】JWT的概念==

概念：全称Json Web Token，是当下最流行的跨域认证的解决方案，是一种授权认证机制

基本原理：

- 服务器认证用户后，返回一个Json数据信息，后续用户访问都已该凭证为依据。示例如下：

```json
{
  "姓名": "张三",
  "角色": "管理员",
  "到期时间": "2018年7月1日0点0分"
}
```

- 为了防止用户篡改该信息，服务器生成这个对象的时候，加上签名，变成密文的方式，然后返回给客户端
- 客户端携带该凭证发送给服务器的时候，服务器首先会校验该信息是否有效，在有效的前提下，才会解析其中的用户信息，供后续使用

---

JWT的组成：

- Header（头部）

  原始数据格式：Json格式；主要存储内容：token的类型（例如：JWT）、所用的加密（签名）算法（例如：HS256）

  ```json
  {
      "alg":"HS256",
      "typ":"JWT"
  }
  ```

  在JWT中的形式：字符串。通过Base64加密算法，对头部原始的Json格式数据加密，得到一串字符串，作为JWT的头部组成

  ```
  eyJhbGciOiJIUzI1NiJ9
  ```
- PayLoad（载荷）：

  原始数据格式：Json格式；主要存储内容：1）需要返回给客户端的数据，用户id、用户名、用户昵称等；2）官方还有一些推荐的信息：签发者、签发时间；载荷部分也被称为Claims（声明）

  ```json
  {
    "name": "张三",
    "role": "管理员",
    "expireTime": "2018年7月1日0点0分"
  }
  ```

  在JWT中的格式：字符串。通过Base64加密算法，对载荷中的数据进行加密，得到JWT的载荷组成

  ```
  eyJqdGkiOiI2MmU2YjdjYzdlYmI0MjU4ODFkYmJhYzk4NDRlNTM0ZiIsInN1YiI6IjEiLCJpc3MiOiJzZyIsImlhdCI6MTcxMzE3NTEzOSwiZXhwIjoxNzEzMTc4NzM5fQ
  ```
- Signature（签名）：

  用途：用于验证JWT的完整性和发送者的身份；组成：将JWT的头部和载荷，用特定的密钥 + 签名算法进行加密，将加密后的结果作为JWT的第三部分组成

  ```js
  var encodedString = base64UrlEncode(header) + '.' + base64UrlEncode(payload);
  var signature = HMACSHA256(encodedString, 'secret');
  ```

  在JWT中的格式：字符串

  ```
  SmmvNepoUOOi3HAcxmtkEA3uXcPkYvoa8AQPo_IQX1Q
  ```
- 整体组成：将头部、载荷和签名用 `.`组合起来

```
eyJhbGciOiJIUzI1NiJ9.eyJqdGkiOiI2MmU2YjdjYzdlYmI0MjU4ODFkYmJhYzk4NDRlNTM0ZiIsInN1YiI6IjEiLCJpc3MiOiJzZyIsImlhdCI6MTcxMzE3NTEzOSwiZXhwIjoxNzEzMTc4NzM5fQ.SmmvNepoUOOi3HAcxmtkEA3uXcPkYvoa8AQPo_IQX1Q
```

---

`客户端携带JWT发送至服务器，服务器解析该JWT`过程详解：

- 获取JWT：通常在请求的头部中
- 分割JWT：将头部、载荷、签名分割开来
- Base64解码：对头部、载荷两部分用Base64解码，还原最初的Json格式
- 验证：依据头部的签名算法 + 服务器保存的密钥，对头部和载荷的编码结果进行签名计算，若计算得到的结果跟前端传来的JWT第三部分一致，证明JWT有效
- 处理载荷：载荷中通常记录用户ID等信息以及JWT的过期时间。首先验证JWT是否过期，若过期，则不可用；若不过期，可继续使用

---

### CSRF、XSS

==【八股】什么是CSRF、XSS==

参考文章：[理解CSRF和XSS](https://zhuanlan.zhihu.com/p/673968062)、[JavaGuide](https://javaguide.cn/system-design/security/basis-of-authority-certification.html#%E4%B8%BA%E4%BB%80%E4%B9%88-cookie-%E6%97%A0%E6%B3%95%E9%98%B2%E6%AD%A2-csrf-%E6%94%BB%E5%87%BB-%E8%80%8C-token-%E5%8F%AF%E4%BB%A5)

---

==【八股】为什么Cookie无法解决CSRF问题，而Token可以有效解决CSRF问题？==

Cookie一般会被自动发送：即用户如果在一个网站上完成登录操作并保存相关信息在Cookie中，那么用户在访问该网站的请求时会自动加入Cookie信息

Token一般不会被自动发送，反而需要程序代码显式的调用：

- 用户将服务器返回的Token信息保存在浏览器，通常是LocalStorage
- 用户在访问该网站的请求时，通过js代码显式的从浏览器的LocalStorage中获取Token，添加到头部中，然后发送给服务器
- 这样情况下，即使第三方能够诱骗用户点击某些链接，只要第三方无法获取用户的Token信息，也是无法成功访问服务器的

### 登录功能的设计流程

**简单：账户、密码登录**

没啥说的，就是上述JWT使用的整个过程

---

**常规：账户、密码、验证码**

对于验证码的处理逻辑，是一个值得设计的点，我么需要保证该验证码是当前用户产生的，而不能不加以判断。

比如：用户A生成验证码ABC；用户B生成验证码BCD；那么用户A就不能拿着验证码BCD去验证。

对于如何将用户与验证码联系起来，有如下几种实现：

实现方式1：

- 用户存储随机数UUID在LocalStorage里面；
- 前端带着随机数，访问后端验证码生成的接口，将验证码返回并展示在前端；
- 前端携带用户名、密码、验证码、UUID提交给后端，后端拿着该UUID再次生成验证码，然后比较验证码是否相同

方式1的弊端：

- 验证码和前端的UUID有一种强相关关系，可以被伪造，可能存在一些以外的Bug
- 验证码的生成应该保持随机性和独立性，而不应该受到约束

---

实现方式2：

- 还是使用UUID+验证码，但是两者不再有相关性，而且两者都由后端生成
- 仿照Session的实现原理，可以使用Redis存储该键-值结构：UUID-验证码
- 将UUID和验证码返回给前端
- 前端携带用户名、密码、验证码、UUID给后端，后端进行验证
- 验证通过后，将UUID从Redis中删除

方式2的好处：

- 解除了UUID和验证码的关联关系
- 通过Redis，可以设置验证码的过期时间（即键-值对在Redis的存储时间），使得登录过程更加合理

## SSO单点登录

==【八股】什么是SSO？==

SSO，单点登录，是一种身份验证和访问控制的方法。用户在一个应用程序中登录之后，在访问其他受信任应用程序的时候就不需要再输入凭据。

---

==【八股】怎样设计一个SSO？==

包含的对象：

- 前台站点：自家不同模块的业务
- SSO站点：为不同模块业务提供的统一登录、登出页面
- SSO服务：用来处理不同前台站点的登录、登出等请求，并将相关信息存储值DB（MySQL、Redis等）
- 数据库：存储数据

大体框图：

![sso-system.png-kblb](./assets/sso-system.png-kblb.png)

## OAuth2.0授权

==【八股】什么是OAuth2.0？有哪些角色？==

概念：OAuth是一个开放标准的授权协议，用于授权第三方应用程序访问用户资源，而不需要直接将凭据提交给第三方应用程序。

示例：生活中第三方网站的QQ登录、微信登录等就是基于OAuth协议。

角色：

- `resource owner`：访问受保护资源的实体，比如人
- `client`：客户端，向受保护资源发起请求的应用程序，比如Web网站，移动应用
- `resource server`：资源服务器，托管受保护的资源，比如LeetCode
- `authorization server`：授权服务器，能够给客户端办法令牌，比如Github服务器。通过GitHub第三方来登录到LeetCode。
- `user-agent`：用户代理，帮助人和客户端沟通的工具，比如浏览器、移动APP等。

---

==【八股】OAuth2.0的工作流程？==

![image-20240511103401927](./assets/image-20240511103401927.png)

- 用户在客户端发起登录请求；
- 客户端将请求发送给授权服务器，进行登录操作，然后授权服务器返回一个授权令牌给客户端；
- 客户端拿着访问令牌，对资源服务器发送请求；
- 资源服务器验证授权令牌的合理性，然后返回受保护的资源。

【补充】

- 访问令牌：客户端能够访问资源服务器资源的凭据；
- 刷新令牌：长期有效，用于获取新的访问令牌，以免旧的访问令牌失效后，再次进行授权登录流程。

---

==【八股】OAuth2.0的四种授权模式有哪些？各自特点？==

参考网站：[CSDN](https://blog.csdn.net/qq_41201565/article/details/107769474)

授权码模式：

- 特点：安全性高、流程复杂，要求第三方应用有自己的服务器（用于后台保存Token）；
- 使用场景：Web应用中。

隐藏式/简化式：

- 特点：流程简单、安全性不高、Token是保存在前端中；
- 使用场景：纯前端式应用，没有自己的后台服务器。

密码式：

- 特点：需要用户输入账户名、密码给第三方应用，第三方应用拿着用户名、密码去访问授权服务器，需要高度信任这个第三方应用；
- 使用场景：其他授权模式无法满足的情况，可以使用该授权方式，原生APP建议使用这个方式，Web不建议使用。

凭据式/客户端模式：

- 特点：授权维度一般不是个人，而是一个应用；
- 使用场景：适用于应用维度的资源共享，服务器之间进行交互，不需要人的参与。

## RBAC、ABAC

==【八股】RBAC、ABAC的区别及各自特点？==

RBAC：

- 概念：基于角色的访问控制，能不能访问某资源，就看访问的用户是哪些角色，这些角色有哪些权限，是否包含该资源的访问权限
- 组成：用户、角色、权限（一个用户可以有多个角色，一个角色可以有多个权限）
- 适用场景：大型组织的权限管理
- 特点：实现相对简单，但是不够灵活

ABAC：

- 概念：基于属性的访问控制，能不能访问某资源，就看用户在此次访问请求中是否具备某属性（时间、日期、系统状态等）
- 组成：属性
- 适用场景：动态分配权限的场景，需要对用户的权限进行灵活更改
- 特点：实现相对复杂，但是足够灵活

# 模块 | 数据安全

## 数据加密 | 哈希算法

==【八股】什么是哈希算法？==

哈希算法也被称为摘要算法，严格来说不属于加密算法，但是可以用于一些**加密场景，比如用户密码加密、文件完整性校验**

哈希算法特点：

- 单向过程：可以将明文密码通过哈希算法加密为密文，但是无法通过密文，还原明文的密码
- 明文的微小改动，可能引起密文的大幅变化

---

==【八股】常见的哈希算法有哪些？==

加密哈希算法：

- 特点：安全性较高、性能较差
- 示例：SHA2、SHA3等

非加密哈希算法：

- 特点：安全性较低、容易被暴力破解，但性能高
- 示例：SipHash、CRC32、MD等

慢哈希算法：

- 特点：性能更好，将哈希结果多次计算，从而增加破解的难度
- 示例：PBKDF2、Bcrypt（专门为加密密码设计）

## 数据加密 | 对称加密、非对称加密

==【八股】什么是对称加密算法？有哪些？==

对称加密算法，加密和解密使用同一个密钥

常见的对称加密算法有：DES、AES、HS256（HMAC-SHA256）

对称加密算法的应用场景：JWT、文件加密、数据库加密、网络传输加密

---

==【八股】什么是非对称加密算法？有哪些？==

非对称加密算法，指加密和解密使用不同的密钥，即公钥和私钥。使用公钥加密，只能用私钥解密；使用私钥加密，只能用公钥解密

常见的非对称加密算法：RSA、DSA、ECDHE

非对称加密算法的应用场景：SSL协议（GitHub）、数字证书（企业应用授权）、货币加密（比特币）

## 敏感词过滤

Trie树算法、DFA算法

## 数据脱敏

==【八股】常用的数据脱敏规则是什么？==

- 替换：将敏感数据的特定位置替换为*
- 删除：随机删除敏感数据的部分内容
- 重排：对敏感数据进行重新排列
- 加噪：在敏感数据中加入一些误差或噪音
- 加密：将敏感数据加密，返回加密后的结果

---

==【八股】常用的数据脱敏工具？==

- Hutool、FastJson等

# 模块 | 23种常见设计模式

**整体分类**

- 创建型模式（5种）：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式
- 结构型模式（7种）：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式
- 行为型模式（11种）：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式

示例代码：[https://github.com/Web-Learn-GSF/Design-Pattern-Java](https://github.com/Web-Learn-GSF/Design-Pattern-Java)

# 模块 | 5+n种代码设计原则

单一职责原则：

- 一个类负责一个单一职责，避免出现职责上的交叉；
- 保证面向接口实现；

开放封闭原则：

- 对于新增开放：任何新的功能可以通过新增类来实现，实现时应尽量抽象代码以隔绝变化；
- 对于修改封闭：设计模块的时候应该允许在不修改内部实现的前提下，完成功能的扩展；

里氏替换原则：

- 对于任何引用父类的地方，可以替换为其子类实现，并且替换后不会产生错误和异常
- 需要满足：子类若覆盖父类方法，入参要更宽松，返回值要更严格；
  - 假设父类接收0-100的参数，子类能接受0-200的参数，就是更宽松的体现；
  - 假设父类接收Animal类型的参数，子类能接收其子类Dog类型的参数，就是更宽松的体现；
  - 假设父类返回值为0-100，子类的返回值为0-50，就是更严格的体现；
  - 假设父类接收Animal类型的返回值，子类能接收其子类Dog类型的参数，就是更严格的体现；

接口分离原则：

- 使用多个专门的接口，而不是使用一个总接口；
- 即一个接口中，不应该包含其不依赖的内容；

依赖倒置原则：

- 代码应该依赖抽象的类，而不应该依赖于具体的类；
- 要面向接口编程，而不是面向实现编程；

最少知识原则：

- 对于使用者，只依赖需要的对象；
- 对于接口提供者，只暴漏应该暴漏的方法；

# 模块 | Java定时任务

# 模块 | Web实时消息推送

## WebSocket

==【八股】什么是WebSocket？==

WebSocket是一种建立在TCP连接上进行全双工通信的协议，可以建立客户端和服务端的双向通信渠道；

客户端和服务端只需要一次握手，就可以创建持久性的连接，并进行双向数据传输。

---

==【八股】WebSocket的建立过程？==

![image-20240520122803319](./assets/image-20240520122803319.png)

1、第一次的HTTP请求：

- 客户端向服务端发送HTTP请求，要求升级为WebSocket协议；
- 服务端接收后，若支持WebSocket操作，将返回HTTP 101状态码，表示已升级为WebSocket协议。

2、后续的WebSocket连接：

- 客户端和服务端建立起WebSocket连接，能够进行双向数据传输，数据以帧的形式进行传送；
- WebSocket会将每条数据切分为多个数据帧率，发送给服务端；服务端接收后，将关联的帧重新组装为完整的消息。

3、WebSocket连接关闭：

- 若是消息传输完毕，需要关闭WebSocket连接，客户端或服务端主动发送一个关闭帧，表示要关闭连接，另一方收到后，也发送一个关闭帧，双方关闭TCP连接。

---

==【八股】WebSocket相关八股（简短回答，汇总）==

1、WebSocket协议只能浏览器发起吗？

不是，WebSocket只是一种协议，客户端和服务端任何一方都可以发起。只是在Web应用开发中，一般是由客户端主动发起。

2、WebSocket和HTTP的关系？

两者都是应用层协议。在WebSocket的连接建立阶段，借助HTTP协议进行握手，握手成功后变为TCP通道，两者不再关联。

3、WebSocket和长轮询的区别？

**等看到长轮询的时候再总结**

4、如何保证WebSocket通信的安全性？

可以使用经过SSL/TLS加密后的安全WebSocket协议：wss

---

==【八股】WebSocket如何处理数据？==

基于事件通知的方式接收数据，主要有4个事件和2个动作：

- 2个动作：发送数据、关闭连接
- 4个事件：open（建立连接时触发）、message（接受到另一方传来的数据时触发）、error（通信发生错误时触发）、close（连接关闭时触发）
