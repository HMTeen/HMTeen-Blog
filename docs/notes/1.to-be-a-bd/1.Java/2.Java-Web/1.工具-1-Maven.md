---
title: 工具-1-Maven
createTime: 2025/03/20 21:17:34
permalink: /ToBeABD/Java/64vyvw92/
outline: [1, 3]
---
---



# Maven

## Maven的jar包冲突

==【八股】怎么判断是否有jar包冲突？==

显示的判断：程序异常抛出

- `java.lang.ClassNotFoundException`
- `java.lang.NoSuchMethodError`
- `java.lang.NoClassDefFoundError`

隐性的判断：程序结果不符合预期

---

==【八股】Maven维护jar包的三个原则？==

依赖传递原则：当导入A包的时候，如果A包依赖B包、C包，B包依赖D包等，最终会把A、B、C、D包都引入；

最短路径优先原则：根据依赖路径的长短，选取较短的那条路径下的jar包；

```
依赖链路一：A -> X -> Y -> Z(21.0)
依赖链路二：B -> Q -> Z(20.0)

最终选用z包的版本为20.0
```

最先声明优先原则：当路径长度相等时，最短路径优先原则就无法判断，此时会使用该原则；

```
依赖链路一：A -> X -> Z(21.0)
依赖链路二：B -> Q -> Z(20.0)

如果在pom.xml文件中，A的声明在B之上，最终选用z的版本为21.0；如果A的声明在B之下，最终选用z的版本为20.0
```

---

==【八股】maven有时候会发生jar包冲突，怎么手动排除掉？==

找到冲突依赖的位置：

- 通过插件查找：maven-helper
- 通过maven命令：`mvn dependency:tree -Dverbose`

手动排除依赖：

- 在 `pom.xml`文件中找到冲突的依赖项，使用 `exclusions`标签排除特定的依赖

更新Maven依赖：

- 修改完之后，重新编译，确保依赖关系正确更新了



## Maven构建的主要环节

1. **clean**：
   - 作用：清理项目，删除之前构建生成的目录和文件，包括 target 目录及其内容。
   - 示例用途：在重新构建项目之前，确保项目处于干净状态，清除之前构建生成的文件。
2. **validate**：
   - 作用：验证项目是否正确且所有必要信息可用。
   - 示例用途：检查项目配置文件的有效性，例如检查 POM 文件的语法错误。
3. **compile**：
   - 作用：编译项目的源代码。
   - 示例用途：将 Java 源代码编译成字节码文件（.class 文件）。
4. **test**：
   - 作用：运行项目中的测试用例。
   - 示例用途：执行单元测试，确保代码的质量和稳定性。
5. **package**：
   - 作用：将项目的编译结果打包成可分发的格式，例如 JAR、WAR、EAR 等。
   - 示例用途：生成可部署的软件包，准备发布或部署到其他环境中。
6. **verify**：
   - 作用：对构建的结果进行验证。
   - 示例用途：检查构建结果是否满足一些质量标准，例如代码规范、静态代码分析等。
7. **install**：
   - 作用：将项目的打包结果安装到本地 Maven 仓库，以便其他项目进行依赖引用。
   - 示例用途：在开发和构建多个相关项目时，确保项目可以在本地 Maven 仓库中被其他项目引用。
8. **site**：
   - 作用：生成项目的站点文档。
   - 示例用途：生成项目的 API 文档、用户手册等站点文档，以便团队成员和用户查阅。
9. **deploy**：
   - 作用：将项目的打包结果部署到远程仓库，以便其他开发人员或项目使用。
   - 示例用途：将项目的构建结果发布到远程 Maven 仓库，使得其他团队成员或外部用户可以访问和使用。



## Pom.xml文件相关

==【八股】dependencyManagement是干什么的？==

是Maven中提供的一种管理依赖版本号的方式。

- 通常在父工程中设置dependencyManagement标签的相关内容，指定项目依赖的jar包和对应的版本。dependencyManagement并不会真实的引入依赖，而是指定所依赖jar包的版本信息；
- 在子工程中导入具体jar包的依赖时，就不需要设置jar包的version，只需要设置好groupId、artifactId，Maven就会沿着父子层级关系，逐层向上查找定义了dependencyManagement的项目，然后使用其中定义的版本号；

当父工程、子工程都定义了dependencyManagement，孙子工程导入相关jar包，其版本找寻规则：

- 先看子工程，若子工程有对应jar包的版本定义，就使用子工程中的jar包版本；若子工程中无相关定义，看父工程
- 再看父工程，若父工程有对应jar包的版本定义，就使用父工程中的jar包版本；若父工程中无相关定义，就选用该jar包的最新版本
